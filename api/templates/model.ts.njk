// tslint:disable:ordered-imports
// tslint:disable:no-consecutive-blank-lines
// tslint:disable:no-trailing-whitespace
// tslint:disable:max-line-length
// tslint:disable:jsdoc-format
// tslint:disable:interface-name
// tslint:disable:no-any
// tslint:disable:object-literal-sort-keys

{% for propName, prop in definition.properties -%}{%
  if prop.$ref -%}{%-
    set realPropName = prop.$ref | replace("#/definitions/", "") -%}
    import { {{ realPropName }} } from "./{{ realPropName }}";{%
  elif prop.items.$ref -%}{%-
    set realPropName = prop.items.$ref | replace("#/definitions/", "") -%}
    import { {{ realPropName }} } from "./{{ realPropName }}";{%
  endif %}{%
endfor %}

/**
 * {{ definition.description | safe }}
 */
{% if definition.type == "object" %}

import * as t from "io-ts";

// required attributes
const {{ definitionName }}R = t.interface({
{% for propName, prop in definition.properties -%}
  {% if definition.required and (definition.required | contains(propName)) %}
    {%-
      if prop.$ref %}{%
        set realPropType = prop.$ref | replace("#/definitions/", "") %}{%
      elif prop.type == "array" and prop.items.$ref %}{%
        set realPropType %}t.readonlyArray({{ prop.items.$ref | replace("#/definitions/", "") }}){% endset %}{%
      else %}{%
        set realPropType %}t.{{ prop.type | replace("integer", "number") }}{% endset %}{%
      endif
    %}
    {{ propName }}: {{ realPropType | safe }},
  {% endif %}
{% endfor %}
})

// optional attributes
const {{ definitionName }}O = t.partial({
{% for propName, prop in definition.properties -%}
  {% if (not definition.required) or (definition.required and not (definition.required | contains(propName))) %}
    {%-
      if prop.$ref %}{%
        set realPropType = prop.$ref | replace("#/definitions/", "") %}{%
      elif prop.type == "array" and prop.items.$ref %}{%
        set realPropType %}t.readonlyArray({{ prop.items.$ref | replace("#/definitions/", "") }}){% endset %}{%
      else %}{%
        set realPropType %}t.{{ prop.type | replace("integer", "number") }}{% endset %}{%
      endif
    %}
    {{ propName }}: {{ realPropType | safe }},
  {% endif %}
{% endfor %}
})

export const {{ definitionName }} = t.intersection([{{ definitionName }}R, {{ definitionName }}O], "{{ definitionName }}");

export type {{ definitionName }} = t.TypeOf<typeof {{ definitionName }}>;

{% elif definition.type == "integer" %}

import { WithinRangeNumber } from "../../utils/numbers";

  {% if definition.minimum and definition.maximum %}

export type {{ definitionName }} = WithinRangeNumber<{{ definition.minimum }}, {{ definition.maximum }}>;

export const {{ definitionName }} = WithinRangeNumber({{ definition.minimum }}, {{ definition.maximum }});

  {% else %}
export type {{ definitionName }} = number;
  {% endif %}
{% elif definition.type == "string" %}
  {% if definition.pattern %}

import { PatternString } from "../../utils/strings";

export type {{ definitionName }} = PatternString<"{{ definition.pattern }}">;

export const {{ definitionName }} = PatternString("{{ definition.pattern }}");

  {% elif definition.minLength and definition.maxLength %}

import { WithinRangeString } from "../../utils/strings";

export type {{ definitionName }} = WithinRangeString<{{ definition.minLength }}, {{ definition.maxLength }}>;

export const {{ definitionName }} = WithinRangeString({{ definition.minLength }}, {{ definition.maxLength }});

  {% elif definition.minLength == 1 %}

import { NonEmptyString } from "../../utils/strings";

export type {{ definitionName }} = NonEmptyString;

export const {{ definitionName }} = NonEmptyString;

  {% elif definition.format == "email" %}

import { EmailString } from "../../utils/strings";

export type {{ definitionName }} = EmailString;

export const {{ definitionName }} = EmailString;

  {% elif definition["x-extensible-enum"] %}

import * as t from "io-ts";

import { enumType } from "../../utils/types";

export enum {{ definitionName }}Enum {
    {% for enum in definition["x-extensible-enum"] %}
      "{{ enum }}" = "{{ enum }}",
    {% endfor %}
}

export const {{ definitionName }} = enumType<{{ definitionName }}Enum>(
  {{ definitionName }}Enum,
  "{{ definitionName }}"
);

export type {{ definitionName }} = t.TypeOf<typeof {{ definitionName }}>;

  {% else %}
export type {{ definitionName }} = string;
  {% endif %}
{% elif definition.type == "array" %}

  {% if definition.items.$ref %}

    {%- set realPropName = definition.items.$ref | replace("#/definitions/", "") -%}

import * as t from "io-ts";

import { {{ realPropName }} } from "./{{ realPropName }}";

export const {{ definitionName }} = t.readonlyArray({{ realPropName }}, "array of {{ realPropName }}");

  {% else %}

export const {{ definitionName }} = t.readonlyArray(t.{{ definition.items.type | replace("integer", "number") }}, "array of {{ definition.items.type | replace("integer", "number") }}");

  {% endif %}

export type {{ definitionName }} = t.TypeOf< typeof {{ realPropName }}>;

{% else %}

// TODO: generate model for definition "{{ definitionName }}"

{% endif %}
